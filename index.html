<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Planet Planter – Full Visible System</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
<style>
body{margin:0;background:#24304f;font-family:sans-serif;}
</style>
</head>
<body>
<script>
const HEX=28, R=8;
let grid=[], selected="red";
let popup="", flash=0;

const SEED={
 red:{n:"住宅",c:"#e57373"},
 green:{n:"緑地",c:"#81c784"},
 blue:{n:"商業",c:"#64b5f6"},
 yellow:{n:"工業",c:"#fff176"},

 dense:{n:"高密度住宅",c:"#d32f2f"},
 town:{n:"ニュータウン",c:"#b71c1c"},
 park:{n:"住宅公園",c:"#66bb6a"},

 forest:{n:"森林公園",c:"#388e3c"},
 flood:{n:"遊水池公園",c:"#26a69a"},

 hub:{n:"商業拠点",c:"#1e88e5"},
 center:{n:"中心市街地",c:"#0d47a1"},

 factory:{n:"工業地帯",c:"#fbc02d"},
 heavy:{n:"重工業地帯",c:"#f57f17"},

 polluted:{n:"公害地区",c:"#757575"},
 disease:{n:"疫病流行",c:"#8d6e63"},
 ruin:{n:"荒廃地区",c:"#424242"}
};

class Hex{
 constructor(q,r){this.q=q;this.r=r;this.seed=null;}
 neighbors(){
  const d=[[1,0],[0,1],[-1,1],[-1,0],[0,-1],[1,-1]];
  return d.map(v=>grid.find(h=>h.q==this.q+v[0]&&h.r==this.r+v[1])).filter(Boolean);
 }
 evolve(s){
  if(this.seed===s) return;
  this.seed=s;
  popup="▶ "+SEED[s].n+" に進化";
  flash=6;
 }
 update(){
  if(!this.seed) return;
  let n=this.neighbors().map(h=>h.seed);

  // 住宅系
  if(this.seed==="red" && n.filter(s=>s==="red").length>=2) this.evolve("dense");
  if(this.seed==="dense" && n.filter(s=>s==="red").length>=3) this.evolve("town");

  // 緑地系
  if(this.seed==="green" && n.filter(s=>s==="green").length>=2) this.evolve("forest");
  if(this.seed==="forest" && n.filter(s=>s==="green").length>=3) this.evolve("flood");

  // 商業系
  if(this.seed==="blue" && n.filter(s=>s==="blue").length>=2) this.evolve("hub");
  if(this.seed==="hub" && n.filter(s=>s==="blue").length>=3) this.evolve("center");

  // 工業系
  if(this.seed==="yellow" && n.filter(s=>s==="yellow").length>=2) this.evolve("factory");
  if(this.seed==="factory" && n.filter(s=>s==="yellow").length>=3) this.evolve("heavy");

  // 合わせ技
  if(this.seed==="red" && n.includes("green")) this.evolve("park");

  // 失敗ルート
  if(this.seed==="yellow" && n.filter(s=>s==="yellow").length>=2 && !n.includes("green"))
    this.evolve("polluted");

  if(this.seed==="red" && n.filter(s=>s==="red").length>=3 && !n.includes("green"))
    this.evolve("disease");

  if((this.seed==="polluted"||this.seed==="disease") && !n.includes("green"))
    this.evolve("ruin");
 }
 draw(){
  let p=hexPix(this.q,this.r);
  stroke(90);
  fill(this.seed?SEED[this.seed].c:"#33406b");
  beginShape();
  for(let i=0;i<6;i++){
   let a=TWO_PI/6*i+PI/6;
   vertex(p.x+cos(a)*HEX,p.y+sin(a)*HEX);
  }
  endShape(CLOSE);
 }
}

function setup(){
 createCanvas(windowWidth,windowHeight);
 for(let q=-R;q<=R;q++)for(let r=-R;r<=R;r++)
  if(abs(q+r)<=R) grid.push(new Hex(q,r));
}

function draw(){
 background("#24304f");
 translate(width/2-160,height/2);
 grid.forEach(h=>{h.update();h.draw();});
 resetMatrix();
 drawUI();
 if(popup){
  fill(255);textAlign(CENTER);textSize(18);
  text(popup,width/2,40);
 }
 if(flash-- >0){
  fill(255,40);rect(0,0,width,height);
 }
}

function mousePressed(){
 if(mouseY>height-120) return;
 let h=pick(mouseX-width/2+160,mouseY-height/2);
 if(h&&!h.seed) h.seed=selected;
}

function mouseClicked(){
 let x=20,y=height-90;
 ["red","green","blue","yellow"].forEach(k=>{
  if(mouseX>x&&mouseX<x+60&&mouseY>y&&mouseY<y+60) selected=k;
  x+=70;
 });
}

function drawUI(){
 let x=20,y=height-90;
 ["red","green","blue","yellow"].forEach(k=>{
  fill(SEED[k].c);rect(x,y,60,60,14);
  fill(40);textSize(10);text(SEED[k].n,x+8,y+35);
  if(selected===k){noFill();stroke(255);rect(x-3,y-3,66,66,16);noStroke();}
  x+=70;
 });

 // 進化ツリー表示
 fill(255);textSize(12);
 text("進化ツリー",width-260,40);
 text("住宅 → 高密度 → ニュータウン",width-260,60);
 text("緑地 → 森林 → 遊水池",width-260,80);
 text("商業 → 拠点 → 中心市街地",width-260,100);
 text("工業 → 工業地帯 → 重工業",width-260,120);
 text("合わせ技：住宅＋緑地 → 住宅公園",width-260,150);
 text("⚠ 工業過多 → 公害 → 荒廃",width-260,180);
 text("⚠ 住宅過密 → 疫病 → 荒廃",width-260,200);
}

function hexPix(q,r){
 return {x:HEX*sqrt(3)*(q+r/2),y:HEX*1.5*r};
}
function pick(x,y){
 let best=null,d=9999;
 grid.forEach(h=>{
  let p=hexPix(h.q,h.r);
  let ds=dist(x,y,p.x,p.y);
  if(ds<d){d=ds;best=h;}
 });
 return d<HEX?best:null;
}
</script>
</body>
</html>
